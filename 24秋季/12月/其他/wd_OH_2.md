### 1. 本周完成的工作

* 对傅里叶分析的收尾工作
  <p>
  
    <p>
                  周期序列的傅里叶级数DFS 和 离散傅里叶变换DFT区别就是信号的周期
  
          DFS信号本身具备周期性,即具有自然周期
  
          DFT信号本身不具备周期性,而是通过人为的序列循环得到的
    </p>
      <p>
                  然而傅里叶变换的性质决定了傅里叶变换会忽略信号的时间信息,
                  这对于研究自然界的大多数信号绝对是不理想的
  
    </p>
          <p>对于更多出现的非平稳信号,只知道包含哪些频率成分是不够的,还需要知道每个频率出现的时间,即做<font size = 4>时频分析</font></p>
      <p>由此学习 <font color="#8a2be2">短时傅里叶变换(STFT)</font>
                <p><font face="黑体"  size=5>短时傅里叶变换 </font> 
                      针对不同时刻的信号进行的傅里叶变换方法,诣在获取不同时段的信号组成,可以视为对不同时段分别进行DFT
    </p><p> <font size = 4>Target:</font>将长时间信号分解为多个等长的小段，并在每个小段上计算傅里叶变换，得到频谱图</p>
      <p>
       引入scipy库中的signal.stft函数:
  
      scipy.signal.stft(x, fs, window, nperseg, noverlap, nfft, detrend, return_oneside, boundary, padded, axis)
      1.x ：传入STFT变换的时域信号
      2.fs : 时域信号的采样频率，默认为1.0
      3.window : 时域信号分割的时候需要的窗函数，常用的窗函数有boxcar，triang，hamming， hann等
      4.nperseg : 窗函数的长度，默认值为256
      5.noverlap : 窗函数重叠数，默认为窗长的一半
      6.nfft : FFT的长度，默认为nperseg，如果设置为大于nperseg会自动进行0填充
      7.return_oneside : True返回复数实部，None返回复数，默认为False
    <p><font size="6">自己随便写的三个正弦波加起来的时频图</font></p>
    
![img_5](https://github.com/user-attachments/assets/41507792-c608-4770-9f09-d2cae5136848)
    <p><font size="6">我用低沉的声音说出“热西德”的声音信号的时频图</font></p>
    
![img_6](https://github.com/user-attachments/assets/b9f207bc-aa73-45a1-bb56-39df1394dc78)
  </p>
      <p>仍有缺陷: 需要手动定义窗函数的属性,即分析一段信号STFT的窗口是固定的,在同次中窗的宽度等都不会发生改变</p>
      <p>在原本的傅里叶分析上有突破,但还是无法满足分析非稳态信号的需求 (高频率适合小窗口 低频率适合大窗口)</p>
      <p>且根据相关文章的阅览,其中导致短时傅里叶存在缺陷的还有一个重要的理论,即<font color="orange">海森堡不确定性原理</font></p>
      <p>就STFT而言,海森堡测不准定理具体表现在STFT分析不平稳信号时受到该原理限制，<font size = 4">信号时域长度与频域集中度成反比</font></p>
      
![img](https://github.com/user-attachments/assets/2e2e0799-279b-4f77-b153-5b9f8f92a331)

  </p>  
    <p>而且对于突变信号傅里叶变换存在<font color = orange>吉布斯效应</font>,用无限长的三角函数是拟合不好的</p>
    <p>由此引入继承了STFT优点并克服STFT部分缺点的<font color="#8a2be2">小波变换</font></p>  
  </p>

  * 学习小波变换(CWT&DWT)
      <p>
            <p><font color="orange">将傅里叶变换中无限长的三角函数基换成了有限长的会衰减的小波基</font></p> 
          
![img_1](https://github.com/user-attachments/assets/1016dd42-c05c-49d2-80ef-7186c80682de)
          从公式中我们可以看到小波变换中存在两个变量:尺度α 和 平移量ζ
            对于傅里叶分析 正余弦波即为它的基函数  而对于小波函数而言 如果存在可控的变化窗 那么也应该存在它的基函数
            在查阅相关资料后 这里引入一个小波基函数morlet (出现疑点:如何选取小波基?)
            Morlet(典型连续小波变换):
![img_2](https://github.com/user-attachments/assets/c7a822b3-3f6f-4e51-83ba-cd452f72d318)
            <p>其傅里叶变换表达式:</p>
![img_3](https://github.com/user-attachments/assets/016ab7a9-f0e3-4c90-b616-3d0f2fc0b383)
            <p>morlet小波变换公式</p>
![img_4](https://github.com/user-attachments/assets/bf29e836-89e6-4fd1-9160-f6dd2483e535)
            小波小波，顾名思义，既要小又要有波动。morlet小波的波动性可以用复三角函数表达，小则用衰减函数表达，数学上把这种小称为有限支撑。
            即morlet小波的有限支撑是通过一个指数衰减函数实现的。复三角函数使其能分析频率（和原始信号乘积积分求极大值），衰减函数使其可以定位时间， 
            他们加起来，才使得morlet小波可以用来做时频分析。（ morlet小波基函数 = 复三角函数 + 衰减函数 ）
            CWT(连续小波变换)：(连续时间上)就是选一个中心频率然后通过尺度变换得到一大堆中心频率，又通过时移得到一系列不同区间的基函数，
           分别和原始信号的某一段（对应基函数的区间）乘积再积分，产生的极值对应的频率就是原始信号这一区间含有的频率。
            ***个人见解: 小波可以认为是一个带通滤波器，只允许频率和小波中心频率（经过尺度伸缩后）相近的信号的通过 (不知道这么说是否严谨)
      </p>
               <font size = 4> Haar(典型离散小波变换):</font>
               <font size = 4>基于Haar变换实现图像融合</font>
                <p>哈尔小波变换的实现算法分为前向变换和逆变换：

                    前向哈尔变换算法：
                    1.输入信号序列。
                    2.使用低通和高通滤波器对输入信号进行分解，分别获得近似系数和细节系数。
                    3.将近似系数作为新的输入重复步骤2，直到达到所需的分解级数。
                  
                    逆哈尔变换算法：
                  
                    1.输入近似系数和细节系数。
                    2.使用相应的重构滤波器将系数合并成一个信号序列。
                    3.重复步骤2，直到达到所需的级数，从而重构原始信号
  <p>
          <font size="5">将彩虹与西安电子科技大学大门融合的效果:</font>
          
<img width="837" alt="input" src="https://github.com/user-attachments/assets/bfc61bed-88ef-4b40-9fa1-370d3965cb71">
 ----------------------------->
<img width="209" alt="print" src="https://github.com/user-attachments/assets/26c89ad6-6bfd-4816-bae7-793fdbe24da3">
</p>
          <p><font size="5">实际上这个代码的实现经过了很长时间的修改,但最后的效果还是拉了一坨大的</font></p>
          <p><font size="4">事实上我的代码更倾向于运用在博客上所谓一半清晰一半模糊的两个图象融合的任务 或者说如果我读的是灰度模式结果会更好</font></p>
          <p><font size="4">但是实际上我的思路是在彩虹的部分进行小波融合 而在非彩虹部分保留原来图像即可</font>></p>
          <p><font size="4">那么接下来登场的就是<font size="6" color="#8a2be2">边缘检测(找到彩虹的位置)</font></font></p>
  </p>
      </p>
  
  * 学习边缘检测
  <p>     
          <p>何为边缘?</p>
          边缘是图像中两个区域之间具有相对不同的灰级特性的边界,或者说是亮度函数突然变化的像素
          边缘检测器是一组重要的局部图像预处理方法,用于定位强度函数中的(急剧)变化
          可以通过使用以下算法来检测边缘上的点 :
              1.一阶导数的局部最大值或最小值  
              2.二阶导数的零交叉点(zero-crossing)
    <p>
          <font size="4">以下就讨论以第二种方式为代表的Canny算子(毕竟里面也包含用Sobel算子进行计算的过程)</font>
          <p> 大致过程:
              
              平滑: 使用高斯滤波器对图像进行平滑，以减少噪声的影响。
              梯度计算: 与Sobel算子类似，使用Sobel算子（或其他方法）计算图像的梯度和方向。
              非极大值抑制: 寻找局部最大值，以细化边缘。
              双阈值和边缘连接: 根据设定的高低阈值来决定边缘的强度，并连接强边缘与弱边缘
</p> <p>其中梯度计算过程需要用分别用水平(检测y方向的边缘)和垂直(检测x方向的边缘)方向的Sobel核对图像平滑图像的强度梯度计算执行滤波</p>
     <p>且应用非最大抑制技术NMS来消除边误检 
          
            a)对每个像素点的梯度方向近似为0,45,90,135,180,225,270,315中的一个
            b)比较该像素点和其梯度方向正负方向的像素点的梯度强度
            c)如果该像素点梯度强度最大则保留,否则抑制(置为0)
</p> <p>由于经过非极大抑制后图像中仍然有很多噪声点 Canny算法应用了双阈值 即阈值上界和下界 即强边界和弱边界(弱边界的话需要确定是否为边缘的像素点邻接)</p>
      <p>进一步处理弱边界:   滞后技术跟踪边界</p>
      <p>由真实边缘引起的弱边缘像素将连接到强边缘像素，而噪声响应未连接。为了跟踪边缘连接，通过查看弱边缘像素及其8个邻域像素，只要其中一个为强边缘像素，则该弱边缘点就可以保留为真实的边缘</p>
  </p>
      <p>这里直接使用opencv提供的canny</p>
      
            edge = cv2.Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient ]]])
            参数 image - 输入图片，必须为单通道的灰度图
            参数 threshold1 和 threshold2 - 分别对应于阈值 minVal 和 maxVal
            参数 apertureSize - 用于计算图片提取的 Sobel kernel 尺寸. 默认为 3.
            参数 L2gradient - 指定计算梯度的等式(默认为False) True的精度会更高
<p>
      
![img_7](https://github.com/user-attachments/assets/ef9755b0-abb5-4420-acf0-26e5df38915f)
      <p>
          <font size="5"> 实际是我们可以得到白云的轮廓</font>
          <p>效果不理想 <font size="5">学习HSV模式下的颜色掩膜创建以及过滤操作 </font> 尝试提取彩虹 得到</p>
          
![rainbow_extracted](https://github.com/user-attachments/assets/ab257623-bf42-4c8d-838d-e2ea832e3a76)
  <p><font size="5">反向提取 得到 </font></p>
         
<img width="401" alt="success_extract" src="https://github.com/user-attachments/assets/8a7ba83d-02ea-4ffe-8c88-e6dba07d3bf2">
 <p><font size="5">终于提取出了理想的彩虹(白云不知道怎么搞掉 估计是它的色彩值跟彩虹叠加是差不多的 就归并了进来) </font></p>
          <p>利用之前写的haar图像融合 得到最终结果</p>

![success_rainbow_extracted](https://github.com/user-attachments/assets/35cf8078-64ff-4f90-b23f-86f115ccc213)

      
</p>
</p>

</p>

### 2. 遇到的困难和问题
* 小波基函数的选取尚可选择, 而融合小波系数的方法有平均值,最大值最小值,还有权重融合等, 各有优劣,只能通过直观比较输出结果进行选择吗？
* 发现一种可能(但还没有尝试):将Haar与CNN结合,我觉得Haar的这种特征提取方式对CNN有很大帮助,可以让CNN快速收敛(由于水平有限,还未发现弊大于利的地方)
* Emboied-AI.pptx这个群里的文件打不开
* Canny双阈值的确定困难(感觉可以通过深度学习训练出理想的阈值)
* 彩虹和白云在掩膜上难以区分 考虑其他方法？
### 3. 解决方案与已采取的措施
* 上述没有提到的问题在自己思考查阅资料后 结合ai查错已经可以实现解决 (上述都是为解决的问题)
  <p>另外我会查阅与相关问题有关的拓展,对错误有一个更深的了解</p>
### 4. 下周工作计划
* 尝试将Haar的特征提取方式和CNN结合,看看最后训练的效率和效果会不会显著提高
* 选取有关具体研究方向(自动驾驶协同感知)的论文进行研读 
### 5. 需要的支持与资源
* 安静的学习环境 流动工位

### 6. 其他备注
* 个人心得 
<p><font size="4">这周学会了很多 接触并掌握了一部分的新的py库:scipy和pywt 开始熟练上网进入库官网的API表内查看函数用法;学会了通过掩膜mask过滤出自己想要的色彩部分;
对于Zotero中论文的整合使用更为得心应手
<p>逐渐适应学习的强度并在逐步提高学习的效率 在大致掌握内置函数原理后 迅速掌握其用法 然后再回头实现代码 并在之后陆续补充相关原理的拓展 (个人认为这样学的效果还不错)</p>
<p>代码中遇到的奇怪问题有些自己看懂报错信息 但是又不知道为什么报错 比如在修改小波转换的逆向过程代码时pywt.waverec2的报错让我不知所措,最后还是换了一种方式才让它成功运行</p>
<p>感觉最近对神经网络的接触较少 更多时间投入在图像处理的方法上 我希望接下来可以更多时间投入神经网络的学习 比如接下来我将对Haar与CNN的结合展开具体实现(我也不确定这是否具有研究价值 希望老师可以对此提点建议)</p>
</font></p>
